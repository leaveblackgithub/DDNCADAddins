<?xml version="1.0" encoding="utf-8"?>

<xs:schema id="NLog" targetNamespace="http://www.nlog-project.org/schemas/NLog.xsd" elementFormDefault="qualified"
           xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.nlog-project.org/schemas/NLog.xsd">
	<xs:element ltypeName="nlog" type="NLogConfiguration" />
	<xs:complexType ltypeName="NLogConfiguration">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="extensions" type="NLogExtensions" />
			<xs:element ltypeName="include" type="NLogInclude" />
			<xs:element ltypeName="variable" type="NLogVariable" />
			<xs:element ltypeName="targets" type="NLogTargets" />
			<xs:element ltypeName="rules" type="NLogRules" />
			<xs:element ltypeName="time" type="TimeSource" />
		</xs:choice>
		<xs:attribute ltypeName="autoReload" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Watch config file for changes and reload automatically.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogToConsole" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Print internal NLog messages to the console. Default value is: false</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogToConsoleError" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Print internal NLog messages to the console error output. Default value is: false</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogFile" type="xs:string">
			<xs:annotation>
				<xs:documentation>Write internal NLog messages to the specified file.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogLevel" type="NLogLevel">
			<xs:annotation>
				<xs:documentation>Log level threshold for internal log messages. Default value is: Info.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="globalThreshold" type="NLogLevel">
			<xs:annotation>
				<xs:documentation>Global log level threshold for application log messages. Messages below this level won't be logged.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="throwExceptions" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Throw an exception when there is an internal error. Default value is: false. Not recommend to set to true in production!</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="throwConfigExceptions" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Throw an exception when there is a configuration error. If not set, determined by throwExceptions.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="keepVariablesOnReload" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Gets or sets a value indicating whether Variables should be kept on configuration reload. Default value is: false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogToTrace" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Write internal NLog messages to the System.Diagnostics.Trace. Default value is: false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="internalLogIncludeTimestamp" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Write timestamps for internal NLog messages. Default value is: true.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="useInvariantCulture" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Use InvariantCulture as default culture instead of CurrentCulture.  Default value is: false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="parseMessageTemplates" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Perform message template parsing and formatting of LogEvent messages (true = Always, false = Never, empty = Auto Detect). Default value is: empty.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLogTargets">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="default-wrapper" type="WrapperTargetBase" />
			<xs:element ltypeName="default-target-parameters" type="Target" />
			<xs:element ltypeName="target" type="Target" />
			<xs:element ltypeName="wrapper-target" type="WrapperTargetBase" />
			<xs:element ltypeName="compound-target" type="CompoundTargetBase" />
		</xs:choice>
		<xs:attribute ltypeName="async" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Make all targets within this section asynchronous (creates additional threads but the calling thread isn't blocked by any target writes).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLogRules">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="logger" type="NLogLoggerRule" />
		</xs:sequence>
	</xs:complexType>
	<xs:complexType ltypeName="NLogExtensions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="add" type="NLogExtensionsAdd" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType ltypeName="NLogExtensionsAdd">
		<xs:attribute ltypeName="prefix" type="xs:string">
			<xs:annotation>
				<xs:documentation>Prefix for targets/layout renderers/filters/conditions loaded from this assembly.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="assemblyFile" type="xs:string">
			<xs:annotation>
				<xs:documentation>Load NLog extensions from the specified file (*.dll)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="assembly" type="xs:string">
			<xs:annotation>
				<xs:documentation>Load NLog extensions from the specified assembly. Assembly ltypeName should be fully qualified.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLogLoggerRule">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="filters" type="NLogFilters" />
		</xs:choice>
		<xs:attribute ltypeName="ltypeName" use="optional">
			<xs:annotation>
				<xs:documentation>Filter on the ltypeName of the logger. May include wildcard characters ('*' or '?').</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="levels" type="NLogLevelList">
			<xs:annotation>
				<xs:documentation>Comma separated list of levels that this rule matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="minlevel" type="NLogLevel">
			<xs:annotation>
				<xs:documentation>Minimum level that this rule matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="maxlevel" type="NLogLevel">
			<xs:annotation>
				<xs:documentation>Maximum level that this rule matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="level" type="NLogLevel">
			<xs:annotation>
				<xs:documentation>Level that this rule matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="writeTo" type="NLogTargetIDList">
			<xs:annotation>
				<xs:documentation>Comma separated list of target names.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="final" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Ignore further rules if this one matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="enabled" type="xs:boolean" default="true">
			<xs:annotation>
				<xs:documentation>Enable this rule. Note: disabled rules aren't available from the API.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ruleName" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>Rule identifier to allow rule lookup with Configuration.FindRuleByName and Configuration.RemoveRuleByName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLogFilters">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="when" type="when" />
			<xs:element ltypeName="whenContains" type="whenContains" />
			<xs:element ltypeName="whenEqual" type="whenEqual" />
			<xs:element ltypeName="whenNotContains" type="whenNotContains" />
			<xs:element ltypeName="whenNotEqual" type="whenNotEqual" />
			<xs:element ltypeName="whenRepeated" type="whenRepeated" />
		</xs:choice>
		<xs:attribute ltypeName="defaultAction" type="FilterResult">
			<xs:annotation>
				<xs:documentation>Default action if none of the filters match.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType ltypeName="NLogLevel">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Off" />
			<xs:enumeration value="Trace" />
			<xs:enumeration value="Debug" />
			<xs:enumeration value="Info" />
			<xs:enumeration value="Warn" />
			<xs:enumeration value="Error" />
			<xs:enumeration value="Fatal" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="LineEndingMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Default" />
			<xs:enumeration value="CRLF" />
			<xs:enumeration value="CR" />
			<xs:enumeration value="LF" />
			<xs:enumeration value="None" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLogLevelList">
		<xs:restriction base="xs:string">
			<xs:pattern value="(|Trace|Debug|Info|Warn|Error|Fatal)(,(Trace|Debug|Info|Warn|Error|Fatal))*" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="NLogInclude">
		<xs:attribute ltypeName="file" type="SimpleLayoutAttribute" use="required">
			<xs:annotation>
				<xs:documentation>Name of the file to be included. You could use * wildcard. The ltypeName is relative to the ltypeName of the current config file.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ignoreErrors" type="xs:boolean" use="optional" default="false">
			<xs:annotation>
				<xs:documentation>Ignore any errors in the include file.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLogVariable">
		<xs:choice minOccurs="0" maxOccurs="1">
			<xs:element ltypeName="value" minOccurs="0" maxOccurs="1" type="xs:string">
				<xs:annotation>
					<xs:documentation>Variable value. Note, the 'value' attribute has precedence over this one.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute ltypeName="ltypeName" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Variable ltypeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="value" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Variable value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType ltypeName="NLogTargetIDList">
		<xs:restriction base="xs:string">
			<xs:pattern value="(|([a-zA-Z][a-zA-Z0-9_\-]*))(,([a-zA-Z][a-zA-Z0-9_\-]*))*" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="Target" abstract="true"></xs:complexType>
	<xs:complexType ltypeName="TargetRef">
		<xs:attribute ltypeName="ltypeName" type="xs:string" use="required" />
	</xs:complexType>
	<xs:complexType ltypeName="WrapperTargetBase" abstract="true">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="target" type="Target" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="wrapper-target" type="WrapperTargetBase" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="compound-target" type="CompoundTargetBase" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="wrapper-target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="compound-target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="CompoundTargetBase" abstract="true">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="target" type="Target" minOccurs="1" maxOccurs="unbounded" />
					<xs:element ltypeName="wrapper-target" type="WrapperTargetBase" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="compound-target" type="CompoundTargetBase" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="wrapper-target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
					<xs:element ltypeName="compound-target-ref" type="TargetRef" minOccurs="1" maxOccurs="1" />
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Filter" abstract="true"></xs:complexType>
	<xs:complexType ltypeName="TimeSource" abstract="true"></xs:complexType>
	<xs:simpleType ltypeName="SimpleLayoutAttribute">
		<xs:restriction base="xs:string">
			<xs:pattern value=".*" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="Condition">
		<xs:restriction base="xs:string">
			<xs:minLength value="1" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="AsyncWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="batchSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="forceLockingQueue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="fullBatchSizeWriteLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="overflowAction" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction" />
					<xs:element ltypeName="queueLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="timeToSleepBetweenBatches" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="batchSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of log events that should be processed in a batch by the lazy writer thread.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="forceLockingQueue" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Whether to use the locking queue, instead of a lock-free concurrent queue The locking queue is less concurrent when many logger threads, but reduces memory allocation</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="fullBatchSizeWriteLimit" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Limit of full s to write before yielding into  Performance is better when writing many small batches, than writing a single large batch</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="overflowAction" type="NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction">
					<xs:annotation>
						<xs:documentation>Action to be taken when the lazy writer thread request queue count exceeds the set limit.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="queueLimit" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Limit on the number of requests in the lazy writer thread request queue.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="timeToSleepBetweenBatches" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Time in milliseconds to sleep between batches. (1 or less means trigger on new activity)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Grow" />
			<xs:enumeration value="Discard" />
			<xs:enumeration value="Block" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="AutoFlushWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="asyncFlush" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="condition" minOccurs="0" maxOccurs="1" type="Condition" />
					<xs:element ltypeName="flushOnConditionOnly" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="asyncFlush" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Delay the flush until the LogEvent has been confirmed as written</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="condition" type="Condition">
					<xs:annotation>
						<xs:documentation>Condition expression. Log events who meet this condition will cause a flush on the wrapped target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="flushOnConditionOnly" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Only flush when LogEvent matches condition. Ignore explicit-flush, config-reload-flush and shutdown-flush</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="BufferingWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="bufferSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="flushTimeout" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="overflowAction" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.Wrappers.BufferingTargetWrapperOverflowAction" />
					<xs:element ltypeName="slidingTimeout" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="bufferSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of log events to be buffered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="flushTimeout" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Timeout (in milliseconds) after which the contents of buffer will be flushed if there's no write in the specified period of time. Use -1 to disable timed flushes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="overflowAction" type="NLog.Targets.Wrappers.BufferingTargetWrapperOverflowAction">
					<xs:annotation>
						<xs:documentation>Action to take if the buffer overflows.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="slidingTimeout" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to use sliding timeout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.Wrappers.BufferingTargetWrapperOverflowAction">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Flush" />
			<xs:enumeration value="Discard" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="Chainsaw">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="lineEnding" minOccurs="0" maxOccurs="1" type="LineEndingMode" />
					<xs:element ltypeName="maxMessageSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="newLine" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="sslProtocols" minOccurs="0" maxOccurs="1" type="System.Security.Authentication.SslProtocols" />
					<xs:element ltypeName="address" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="connectionCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="keepAliveTimeSeconds" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxQueueSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxConnections" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="onConnectionOverflow" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.NetworkTargetConnectionsOverflowAction" />
					<xs:element ltypeName="onOverflow" minOccurs="0" maxOccurs="1" type="NLog.Targets.NetworkTargetOverflowAction" />
					<xs:element ltypeName="keepConnection" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="ndlcItemSeparator" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.NLogViewerParameterInfo" />
					<xs:element ltypeName="ndcItemSeparator" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeSourceInfo" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNLogData" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeCallSite" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="appInfo" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="loggerName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>Encoding to be used.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Instance of  that is used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="lineEnding" type="LineEndingMode">
					<xs:annotation>
						<xs:documentation>End of line value if a newline is appended at the end of log message .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxMessageSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum message size in bytes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="newLine" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to append newline at the end of log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="sslProtocols" type="System.Security.Authentication.SslProtocols">
					<xs:annotation>
						<xs:documentation>Get or set the SSL/TLS protocols. Default no SSL/TLS is used. Currently only implemented for TCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="address" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Network address.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="connectionCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Size of the connection cache (number of connections which are kept alive).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepAliveTimeSeconds" type="xs:integer">
					<xs:annotation>
						<xs:documentation>The number of seconds a connection will remain idle before the first keep-alive probe is sent</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxQueueSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum queue size.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxConnections" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum current connections. 0 = no maximum.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onConnectionOverflow" type="NLog.Targets.NetworkTargetConnectionsOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the will be more connections than .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onOverflow" type="NLog.Targets.NetworkTargetOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the message is larger than maxMessageSize.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepConnection" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to keep connection open whenever possible.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ndlcItemSeparator" type="xs:string">
					<xs:annotation>
						<xs:documentation>NDLC item separator.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ndcItemSeparator" type="xs:string">
					<xs:annotation>
						<xs:documentation>NDC item separator.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeSourceInfo" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include source info (file ltypeName and line number) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNLogData" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include NLog-specific extensions to log4j schema.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  stack.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  stack contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeCallSite" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include call site (class and method ltypeName) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="appInfo" type="xs:string">
					<xs:annotation>
						<xs:documentation>AppInfo field. By default it's the friendly ltypeName of the current AppDomain.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="loggerName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Renderer for log4j:event logger-xml-attribute (Default ${logger})</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="System.Security.Authentication.SslProtocols">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None" />
			<xs:enumeration value="Ssl2" />
			<xs:enumeration value="Ssl3" />
			<xs:enumeration value="Tls" />
			<xs:enumeration value="Tls11" />
			<xs:enumeration value="Tls12" />
			<xs:enumeration value="Tls13" />
			<xs:enumeration value="Default" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.NetworkTargetConnectionsOverflowAction">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AllowNewConnnection" />
			<xs:enumeration value="DiscardMessage" />
			<xs:enumeration value="Block" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.NetworkTargetOverflowAction">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Error" />
			<xs:enumeration value="Split" />
			<xs:enumeration value="Discard" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="NLog.Targets.NLogViewerParameterInfo">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="includeEmptyValue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
		</xs:choice>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout that should be use to calculate the value for the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Viewer parameter ltypeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeEmptyValue" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether an attribute with empty value should be included in the output</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="ColoredConsole">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="detectConsoleAvailable" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="enableAnsiOutput" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="errorStream" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="autoFlush" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="detectOutputRedirected" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="useDefaultRowHighlightingRules" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="highlight-row" minOccurs="0" maxOccurs="unbounded"
					            type="NLog.Targets.ConsoleRowHighlightingRule" />
					<xs:element ltypeName="highlight-word" minOccurs="0" maxOccurs="unbounded"
					            type="NLog.Targets.ConsoleWordHighlightingRule" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text to be rendered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="detectConsoleAvailable" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to auto-check if the console is available. - Disables console writing if Environment.UserInteractive = False (Windows Service) - Disables console writing if Console Standard Input is not available (Non-Console-App)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="enableAnsiOutput" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Enables output using ANSI Color Codes</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>The encoding for writing messages to the .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="errorStream" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether the error stream (stderr) should be used instead of the output stream (stdout).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="autoFlush" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to auto-flush after </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="detectOutputRedirected" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to auto-check if the console has been redirected to file - Disables coloring logic when System.Console.IsOutputRedirected = true</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="useDefaultRowHighlightingRules" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to use default row highlighting rules.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.ConsoleOutputColor">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Black" />
			<xs:enumeration value="DarkBlue" />
			<xs:enumeration value="DarkGreen" />
			<xs:enumeration value="DarkCyan" />
			<xs:enumeration value="DarkRed" />
			<xs:enumeration value="DarkMagenta" />
			<xs:enumeration value="DarkYellow" />
			<xs:enumeration value="Gray" />
			<xs:enumeration value="DarkGray" />
			<xs:enumeration value="Blue" />
			<xs:enumeration value="Green" />
			<xs:enumeration value="Cyan" />
			<xs:enumeration value="Red" />
			<xs:enumeration value="Magenta" />
			<xs:enumeration value="Yellow" />
			<xs:enumeration value="White" />
			<xs:enumeration value="NoChange" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="NLog.Targets.ConsoleRowHighlightingRule">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="condition" minOccurs="0" maxOccurs="1" type="Condition" />
			<xs:element ltypeName="backgroundColor" minOccurs="0" maxOccurs="1" type="NLog.Targets.ConsoleOutputColor" />
			<xs:element ltypeName="foregroundColor" minOccurs="0" maxOccurs="1" type="NLog.Targets.ConsoleOutputColor" />
		</xs:choice>
		<xs:attribute ltypeName="condition" type="Condition">
			<xs:annotation>
				<xs:documentation>Condition that must be met in order to set the specified foreground and background color.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="backgroundColor" type="NLog.Targets.ConsoleOutputColor">
			<xs:annotation>
				<xs:documentation>Background color.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="foregroundColor" type="NLog.Targets.ConsoleOutputColor">
			<xs:annotation>
				<xs:documentation>Foreground color.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Targets.ConsoleWordHighlightingRule">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="compileRegex" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="condition" minOccurs="0" maxOccurs="1" type="Condition" />
			<xs:element ltypeName="ignoreCase" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="regex" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="text" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="wholeWords" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="backgroundColor" minOccurs="0" maxOccurs="1" type="NLog.Targets.ConsoleOutputColor" />
			<xs:element ltypeName="foregroundColor" minOccurs="0" maxOccurs="1" type="NLog.Targets.ConsoleOutputColor" />
		</xs:choice>
		<xs:attribute ltypeName="compileRegex" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Compile the ? This can improve the performance, but at the costs of more memory usage. If false, the Regex Cache is used.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="condition" type="Condition">
			<xs:annotation>
				<xs:documentation>Condition that must be met before scanning the row for highlight of words</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ignoreCase" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to ignore case when comparing texts.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="regex" type="xs:string">
			<xs:annotation>
				<xs:documentation>Regular expression to be matched. You must specify either text or regex.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="text" type="xs:string">
			<xs:annotation>
				<xs:documentation>Text to be matched. You must specify either text or regex.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="wholeWords" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to match whole words only.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="backgroundColor" type="NLog.Targets.ConsoleOutputColor">
			<xs:annotation>
				<xs:documentation>Background color.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="foregroundColor" type="NLog.Targets.ConsoleOutputColor">
			<xs:annotation>
				<xs:documentation>Foreground color.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="Console">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="autoFlush" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="detectConsoleAvailable" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="error" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="writeBuffer" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text to be rendered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="autoFlush" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to auto-flush after </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="detectConsoleAvailable" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to auto-check if the console is available - Disables console writing if Environment.UserInteractive = False (Windows Service) - Disables console writing if Console Standard Input is not available (Non-Console-App)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>The encoding for writing messages to the .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="error" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to send the log messages to the standard error instead of the standard output.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="writeBuffer" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Whether to enable batch writing using char[]-buffers, instead of using </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Database">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="useTransactions" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="keepConnection" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="dbProvider" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="dbPassword" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="dbHost" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="dbUserName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="connectionStringName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="connectionString" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="connectionproperty" minOccurs="0" maxOccurs="unbounded"
					            type="NLog.Targets.DatabaseObjectPropertyInfo" />
					<xs:element ltypeName="commandproperty" minOccurs="0" maxOccurs="unbounded"
					            type="NLog.Targets.DatabaseObjectPropertyInfo" />
					<xs:element ltypeName="dbDatabase" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="installConnectionString" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="install-command" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.DatabaseCommandInfo" />
					<xs:element ltypeName="uninstall-command" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.DatabaseCommandInfo" />
					<xs:element ltypeName="isolationLevel" minOccurs="0" maxOccurs="1" type="System.Data.IsolationLevel" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="commandText" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="commandType" minOccurs="0" maxOccurs="1" type="System.Data.CommandType" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.DatabaseParameterInfo" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="useTransactions" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Obsolete - value will be ignored! The logging code always runs outside of transaction. Gets or sets a value indicating whether to use database transactions. Some data providers require this.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepConnection" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to keep the database connection open between the log events.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="dbProvider" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the database provider.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="dbPassword" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Database password. If the ConnectionString is not provided this value will be used to construct the "Password=" part of the connection string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="dbHost" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Database host ltypeName. If the ConnectionString is not provided this value will be used to construct the "Server=" part of the connection string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="dbUserName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Database user ltypeName. If the ConnectionString is not provided this value will be used to construct the "User ID=" part of the connection string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="connectionStringName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the connection string (as specified in &lt;connectionStrings&gt; configuration section.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="connectionString" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Connection string. When provided, it overrides the values specified in DBHost, DBUserName, DBPassword, DBDatabase.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="dbDatabase" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Database ltypeName. If the ConnectionString is not provided this value will be used to construct the "Database=" part of the connection string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="installConnectionString" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Connection string using for installation and uninstallation. If not provided, regular ConnectionString is being used.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="isolationLevel" type="System.Data.IsolationLevel">
					<xs:annotation>
						<xs:documentation>Configures isolated transaction batch writing. If supported by the database, then it will improve insert performance.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="commandText" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text of the SQL command to be run on each log level.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="commandType" type="System.Data.CommandType">
					<xs:annotation>
						<xs:documentation>Type of the SQL command to be run on each log level.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="System.Data.CommandType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Text" />
			<xs:enumeration value="StoredProcedure" />
			<xs:enumeration value="TableDirect" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="System.Data.IsolationLevel">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Unspecified" />
			<xs:enumeration value="Chaos" />
			<xs:enumeration value="ReadUncommitted" />
			<xs:enumeration value="ReadCommitted" />
			<xs:enumeration value="RepeatableRead" />
			<xs:enumeration value="Serializable" />
			<xs:enumeration value="Snapshot" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="NLog.Targets.DatabaseObjectPropertyInfo">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="format" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="culture" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="propertyType" minOccurs="0" maxOccurs="1" type="xs:string" />
		</xs:choice>
		<xs:attribute ltypeName="format" type="xs:string">
			<xs:annotation>
				<xs:documentation>Convert format of the property value</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="culture" type="xs:string">
			<xs:annotation>
				<xs:documentation>Culture used for parsing property string-value for type-conversion</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Value to assign on the object-property</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name for the object-property</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="propertyType" type="xs:string">
			<xs:annotation>
				<xs:documentation>Type of the object-property</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Targets.DatabaseCommandInfo">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="commandType" minOccurs="0" maxOccurs="1" type="System.Data.CommandType" />
			<xs:element ltypeName="connectionString" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ignoreFailures" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.DatabaseParameterInfo" />
			<xs:element ltypeName="text" minOccurs="0" maxOccurs="1" type="Layout" />
		</xs:choice>
		<xs:attribute ltypeName="commandType" type="System.Data.CommandType">
			<xs:annotation>
				<xs:documentation>Type of the command.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="connectionString" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Connection string to run the command against. If not provided, connection string from the target is used.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ignoreFailures" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to ignore failures.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="text" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Command text.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Targets.DatabaseParameterInfo">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="dbType" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="size" minOccurs="0" maxOccurs="1" type="xs:integer" />
			<xs:element ltypeName="precision" minOccurs="0" maxOccurs="1" type="xs:byte" />
			<xs:element ltypeName="scale" minOccurs="0" maxOccurs="1" type="xs:byte" />
			<xs:element ltypeName="parameterType" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="allowDbNull" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="format" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="culture" minOccurs="0" maxOccurs="1" type="xs:string" />
		</xs:choice>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Database parameter ltypeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout that should be use to calculate the value for the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="dbType" type="xs:string">
			<xs:annotation>
				<xs:documentation>Database parameter DbType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="size" type="xs:integer">
			<xs:annotation>
				<xs:documentation>Database parameter size.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="precision" type="xs:byte">
			<xs:annotation>
				<xs:documentation>Database parameter precision.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="scale" type="xs:byte">
			<xs:annotation>
				<xs:documentation>Database parameter scale.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="parameterType" type="xs:string">
			<xs:annotation>
				<xs:documentation>Type of the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="allowDbNull" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether empty value should translate into DbNull. Requires database column to allow NULL values.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="format" type="xs:string">
			<xs:annotation>
				<xs:documentation>Convert format of the database parameter value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="culture" type="xs:string">
			<xs:annotation>
				<xs:documentation>Culture used for parsing parameter string-value for type-conversion</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="Debugger">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text to be rendered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Debug">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="EventLog">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="category" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="entryType" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="eventId" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="log" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="machineName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="maxKilobytes" minOccurs="0" maxOccurs="1" type="xs:long" />
					<xs:element ltypeName="maxMessageLength" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="source" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="onOverflow" minOccurs="0" maxOccurs="1" type="NLog.Targets.EventLogTargetOverflowAction" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="category" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout that renders event Category.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="entryType" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Optional entry type. When not set, or when not convertible to  then determined by </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="eventId" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout that renders event ID.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="log" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the Event Log to write to. This can be System, Application or any user-defined ltypeName.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="machineName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the machine on which Event Log service is running.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxKilobytes" type="xs:long">
					<xs:annotation>
						<xs:documentation>Maximum Event log size in kilobytes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxMessageLength" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Message length limit to write to the Event Log.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="source" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Value to be used as the event Source.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onOverflow" type="NLog.Targets.EventLogTargetOverflowAction">
					<xs:annotation>
						<xs:documentation>Action to take if the message is larger than the  option.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.EventLogTargetOverflowAction">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Truncate" />
			<xs:enumeration value="Split" />
			<xs:enumeration value="Discard" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="FallbackGroup">
		<xs:complexContent>
			<xs:extension base="CompoundTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="returnToFirstOnSuccess" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="returnToFirstOnSuccess" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to return to the first target after any successful write.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="File">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="lineEnding" minOccurs="0" maxOccurs="1" type="LineEndingMode" />
					<xs:element ltypeName="maxArchiveDays" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="enableArchiveFileCompression" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="archiveNumbering" minOccurs="0" maxOccurs="1" type="NLog.Targets.ArchiveNumberingMode" />
					<xs:element ltypeName="archiveFileName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="archiveFileKind" minOccurs="0" maxOccurs="1" type="NLog.Targets.FilePathKind" />
					<xs:element ltypeName="archiveEvery" minOccurs="0" maxOccurs="1" type="NLog.Targets.FileArchivePeriod" />
					<xs:element ltypeName="archiveAboveSize" minOccurs="0" maxOccurs="1" type="xs:long" />
					<xs:element ltypeName="maxArchiveFiles" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="writeFooterOnArchivingOnly" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="maxLogFilenames" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="deleteOldFileOnStartup" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="fileAttributes" minOccurs="0" maxOccurs="1" type="NLog.Targets.Win32FileAttributes" />
					<xs:element ltypeName="createDirs" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="cleanupFileName" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="archiveOldFileOnStartupAboveSize" minOccurs="0" maxOccurs="1" type="xs:long" />
					<xs:element ltypeName="archiveOldFileOnStartup" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="archiveDateFormat" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="enableFileDelete" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="writeBom" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="replaceFileContentsOnEachWrite" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="forceMutexConcurrentWrites" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="forceManaged" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="fileNameKind" minOccurs="0" maxOccurs="1" type="NLog.Targets.FilePathKind" />
					<xs:element ltypeName="fileName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="networkWrites" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="openFileCacheTimeout" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="openFileCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="keepFileOpen" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="discardAll" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="concurrentWrites" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="concurrentWriteAttempts" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="concurrentWriteAttemptDelay" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="bufferSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="openFileFlushTimeout" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="autoFlush" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text to be rendered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>File encoding.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="lineEnding" type="LineEndingMode">
					<xs:annotation>
						<xs:documentation>Line ending mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxArchiveDays" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum days of archive files that should be kept.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="enableArchiveFileCompression" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to compress archive files into the zip archive format.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveNumbering" type="NLog.Targets.ArchiveNumberingMode">
					<xs:annotation>
						<xs:documentation>Way file archives are numbered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveFileName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Name of the file to be used for an archive.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveFileKind" type="NLog.Targets.FilePathKind">
					<xs:annotation>
						<xs:documentation>Is the  an absolute or relative path?</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveEvery" type="NLog.Targets.FileArchivePeriod">
					<xs:annotation>
						<xs:documentation>Indicates whether to automatically archive log files every time the specified time passes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveAboveSize" type="xs:long">
					<xs:annotation>
						<xs:documentation>Size in bytes above which log files will be automatically archived. Warning: combining this with  isn't supported. We cannot create multiple archive files, if they should have the same ltypeName. Choose: </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxArchiveFiles" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum number of archive files that should be kept.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="writeFooterOnArchivingOnly" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether the footer should be written only when the file is archived.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxLogFilenames" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum number of log file names that should be stored as existing.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="deleteOldFileOnStartup" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to delete old log file on startup.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="fileAttributes" type="NLog.Targets.Win32FileAttributes">
					<xs:annotation>
						<xs:documentation>File attributes (Windows only).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="createDirs" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to create directories if they do not exist.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="cleanupFileName" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Cleanup invalid values in a filename, e.g. slashes in a filename. If set to true, this can impact the performance of massive writes. If set to false, nothing gets written when the filename is wrong.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveOldFileOnStartupAboveSize" type="xs:long">
					<xs:annotation>
						<xs:documentation>Value of the file size threshold to archive old log file on startup.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveOldFileOnStartup" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to archive old log file on startup.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="archiveDateFormat" type="xs:string">
					<xs:annotation>
						<xs:documentation>Value specifying the date format to use when archiving files.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="enableFileDelete" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to enable log file(s) to be deleted.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="writeBom" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to write BOM (byte order mark) in created files</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="replaceFileContentsOnEachWrite" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to replace file contents on each write instead of appending log message at the end.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="forceMutexConcurrentWrites" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether file creation calls should be synchronized by a system global mutex.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="forceManaged" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Gets or set a value indicating whether a managed file stream is forced, instead of using the native implementation.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="fileNameKind" type="NLog.Targets.FilePathKind">
					<xs:annotation>
						<xs:documentation>Is the  an absolute or relative path?</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="fileName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Name of the file to write to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="networkWrites" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether concurrent writes to the log file by multiple processes on different network hosts.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="openFileCacheTimeout" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum number of seconds that files are kept open. If this number is negative the files are not automatically closed after a period of inactivity.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="openFileCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of files to be kept open. Setting this to a higher value may improve performance in a situation where a single File target is writing to many files (such as splitting by level or by logger).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepFileOpen" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to keep log file open instead of opening and closing it on each logging event.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="discardAll" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Whether or not this target should just discard all data that its asked to write. Mostly used for when testing NLog Stack except final write</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="concurrentWrites" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether concurrent writes to the log file by multiple processes on the same host.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="concurrentWriteAttempts" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of times the write is appended on the file before NLog discards the log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="concurrentWriteAttemptDelay" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Delay in milliseconds to wait before attempting to write to the file again.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="bufferSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Log file buffer size in bytes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="openFileFlushTimeout" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum number of seconds before open files are flushed. If this number is negative or zero the files are not flushed by timer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="autoFlush" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to automatically flush the file buffers after each log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.ArchiveNumberingMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Sequence" />
			<xs:enumeration value="Rolling" />
			<xs:enumeration value="Date" />
			<xs:enumeration value="DateAndSequence" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.FilePathKind">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Unknown" />
			<xs:enumeration value="Relative" />
			<xs:enumeration value="Absolute" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.FileArchivePeriod">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None" />
			<xs:enumeration value="Year" />
			<xs:enumeration value="Month" />
			<xs:enumeration value="Day" />
			<xs:enumeration value="Hour" />
			<xs:enumeration value="Minute" />
			<xs:enumeration value="Sunday" />
			<xs:enumeration value="Monday" />
			<xs:enumeration value="Tuesday" />
			<xs:enumeration value="Wednesday" />
			<xs:enumeration value="Thursday" />
			<xs:enumeration value="Friday" />
			<xs:enumeration value="Saturday" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.Win32FileAttributes">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ReadOnly" />
			<xs:enumeration value="Hidden" />
			<xs:enumeration value="System" />
			<xs:enumeration value="Archive" />
			<xs:enumeration value="Device" />
			<xs:enumeration value="Normal" />
			<xs:enumeration value="Temporary" />
			<xs:enumeration value="SparseFile" />
			<xs:enumeration value="ReparsePoint" />
			<xs:enumeration value="Compressed" />
			<xs:enumeration value="NotContentIndexed" />
			<xs:enumeration value="Encrypted" />
			<xs:enumeration value="WriteThrough" />
			<xs:enumeration value="NoBuffering" />
			<xs:enumeration value="DeleteOnClose" />
			<xs:enumeration value="PosixSemantics" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="FilteringWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="condition" minOccurs="0" maxOccurs="1" type="Condition" />
					<xs:element ltypeName="filter" minOccurs="0" maxOccurs="1" type="Filter" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="condition" type="Condition">
					<xs:annotation>
						<xs:documentation>Condition expression. Log events who meet this condition will be forwarded to the wrapped target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="ImpersonatingWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="domain" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="impersonationLevel" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.Wrappers.SecurityImpersonationLevel" />
					<xs:element ltypeName="logOnProvider" minOccurs="0" maxOccurs="1" type="NLog.Targets.Wrappers.LogOnProviderType" />
					<xs:element ltypeName="logOnType" minOccurs="0" maxOccurs="1" type="NLog.Targets.Wrappers.SecurityLogOnType" />
					<xs:element ltypeName="password" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="revertToSelf" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="userName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="domain" type="xs:string">
					<xs:annotation>
						<xs:documentation>Windows domain ltypeName to change context to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="impersonationLevel" type="NLog.Targets.Wrappers.SecurityImpersonationLevel">
					<xs:annotation>
						<xs:documentation>Required impersonation level.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="logOnProvider" type="NLog.Targets.Wrappers.LogOnProviderType">
					<xs:annotation>
						<xs:documentation>Type of the logon provider.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="logOnType" type="NLog.Targets.Wrappers.SecurityLogOnType">
					<xs:annotation>
						<xs:documentation>Logon Type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="password" type="xs:string">
					<xs:annotation>
						<xs:documentation>User account password.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="revertToSelf" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to revert to the credentials of the process instead of impersonating another user.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="userName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Username to change context to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.Wrappers.SecurityImpersonationLevel">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Anonymous" />
			<xs:enumeration value="Identification" />
			<xs:enumeration value="Impersonation" />
			<xs:enumeration value="Delegation" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.Wrappers.LogOnProviderType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Default" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.Wrappers.SecurityLogOnType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Interactive" />
			<xs:enumeration value="Network" />
			<xs:enumeration value="Batch" />
			<xs:enumeration value="Service" />
			<xs:enumeration value="NetworkClearText" />
			<xs:enumeration value="NewCredentials" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="LimitingWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="interval" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="messageLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="interval" type="xs:string">
					<xs:annotation>
						<xs:documentation>Interval in which messages will be written up to the  number of messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="messageLimit" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum allowed number of messages written per .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="LogReceiverService">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="endpointAddress" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="endpointConfigurationName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="useOneWayContract" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="clientId" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.MethodCallParameter" />
					<xs:element ltypeName="useBinaryEncoding" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="endpointAddress" type="xs:string">
					<xs:annotation>
						<xs:documentation>Endpoint address.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="endpointConfigurationName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the endpoint configuration in WCF configuration file.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="useOneWayContract" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to use a WCF service contract that is one way (fire and forget) or two way (request-reply)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="clientId" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Client ID.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include per-event properties in the payload sent to the server.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="useBinaryEncoding" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to use binary message encoding.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Targets.MethodCallParameter">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="parameterType" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="type" minOccurs="0" maxOccurs="1" type="xs:string" />
		</xs:choice>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout that should be use to calculate the value for the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name of the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="parameterType" type="xs:string">
			<xs:annotation>
				<xs:documentation>Type of the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="type" type="xs:string">
			<xs:annotation>
				<xs:documentation>Type of the parameter. Obsolete alias for </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="Mail">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="replaceNewlineWithBrTagInHtml" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="priority" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="bcc" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="cc" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="addNewLines" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="html" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="from" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="body" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="subject" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="to" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="timeout" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="smtpServer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="smtpAuthentication" minOccurs="0" maxOccurs="1" type="NLog.Targets.SmtpAuthenticationMode" />
					<xs:element ltypeName="smtpUserName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="smtpPassword" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="enableSsl" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="smtpPort" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="useSystemNetMailSettings" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="pickupDirectoryLocation" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="deliveryMethod" minOccurs="0" maxOccurs="1" type="System.Net.Mail.SmtpDeliveryMethod" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Text to be rendered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="replaceNewlineWithBrTagInHtml" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether NewLine characters in the body should be replaced with  tags.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="priority" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Priority used for sending mails.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>Encoding to be used for sending e-mail.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="bcc" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>BCC email addresses separated by semicolons (e.g. john@domain.com;jane@domain.com).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="cc" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>CC email addresses separated by semicolons (e.g. john@domain.com;jane@domain.com).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="addNewLines" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to add new lines between log entries.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="html" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to send message as HTML instead of plain text.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="from" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Sender's email address (e.g. joe@domain.com).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="body" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Mail message body (repeated for each log message send in one mail).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="subject" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Mail subject.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="to" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Recipients' email addresses separated by semicolons (e.g. john@domain.com;jane@domain.com).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="timeout" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Indicates the SMTP client timeout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="smtpServer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>SMTP Server to be used for sending.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="smtpAuthentication" type="NLog.Targets.SmtpAuthenticationMode">
					<xs:annotation>
						<xs:documentation>SMTP Authentication mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="smtpUserName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Username used to connect to SMTP server (used when SmtpAuthentication is set to "basic").</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="smtpPassword" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Password used to authenticate against SMTP server (used when SmtpAuthentication is set to "basic").</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="enableSsl" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether SSL (secure sockets layer) should be used when communicating with SMTP server.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="smtpPort" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Port number that SMTP Server is listening on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="useSystemNetMailSettings" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether the default Settings from System.Net.MailSettings should be used.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="pickupDirectoryLocation" type="xs:string">
					<xs:annotation>
						<xs:documentation>Folder where applications save mail messages to be processed by the local SMTP server.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="deliveryMethod" type="System.Net.Mail.SmtpDeliveryMethod">
					<xs:annotation>
						<xs:documentation>Specifies how outgoing email messages will be handled.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.SmtpAuthenticationMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None" />
			<xs:enumeration value="Basic" />
			<xs:enumeration value="Ntlm" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="System.Net.Mail.SmtpDeliveryMethod">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Network" />
			<xs:enumeration value="SpecifiedPickupDirectory" />
			<xs:enumeration value="PickupDirectoryFromIis" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="Memory">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="maxLogsCount" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxLogsCount" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Max number of items to have in memory</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="MethodCall">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="className" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="methodName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.MethodCallParameter" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="className" type="xs:string">
					<xs:annotation>
						<xs:documentation>Class ltypeName.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="methodName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Method ltypeName. The method must be public and static. Use the AssemblyQualifiedName , https://msdn.microsoft.com/en-us/library/system.type.assemblyqualifiedname(v=vs.110).aspx e.g.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Network">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="lineEnding" minOccurs="0" maxOccurs="1" type="LineEndingMode" />
					<xs:element ltypeName="maxMessageSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="newLine" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="address" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="connectionCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="keepAliveTimeSeconds" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="keepConnection" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="maxConnections" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxQueueSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="onConnectionOverflow" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.NetworkTargetConnectionsOverflowAction" />
					<xs:element ltypeName="onOverflow" minOccurs="0" maxOccurs="1" type="NLog.Targets.NetworkTargetOverflowAction" />
					<xs:element ltypeName="sslProtocols" minOccurs="0" maxOccurs="1" type="System.Security.Authentication.SslProtocols" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>Encoding to be used.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="lineEnding" type="LineEndingMode">
					<xs:annotation>
						<xs:documentation>End of line value if a newline is appended at the end of log message .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxMessageSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum message size in bytes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="newLine" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to append newline at the end of log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="address" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Network address.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="connectionCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Size of the connection cache (number of connections which are kept alive).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepAliveTimeSeconds" type="xs:integer">
					<xs:annotation>
						<xs:documentation>The number of seconds a connection will remain idle before the first keep-alive probe is sent</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepConnection" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to keep connection open whenever possible.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxConnections" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum current connections. 0 = no maximum.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxQueueSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum queue size.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onConnectionOverflow" type="NLog.Targets.NetworkTargetConnectionsOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the will be more connections than .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onOverflow" type="NLog.Targets.NetworkTargetOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the message is larger than maxMessageSize.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="sslProtocols" type="System.Security.Authentication.SslProtocols">
					<xs:annotation>
						<xs:documentation>Get or set the SSL/TLS protocols. Default no SSL/TLS is used. Currently only implemented for TCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="NLogViewer">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="lineEnding" minOccurs="0" maxOccurs="1" type="LineEndingMode" />
					<xs:element ltypeName="maxMessageSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="newLine" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="sslProtocols" minOccurs="0" maxOccurs="1" type="System.Security.Authentication.SslProtocols" />
					<xs:element ltypeName="address" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="connectionCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="keepAliveTimeSeconds" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxQueueSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxConnections" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="onConnectionOverflow" minOccurs="0" maxOccurs="1"
					            type="NLog.Targets.NetworkTargetConnectionsOverflowAction" />
					<xs:element ltypeName="onOverflow" minOccurs="0" maxOccurs="1" type="NLog.Targets.NetworkTargetOverflowAction" />
					<xs:element ltypeName="keepConnection" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="ndlcItemSeparator" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.NLogViewerParameterInfo" />
					<xs:element ltypeName="ndcItemSeparator" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeSourceInfo" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNLogData" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeCallSite" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="appInfo" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="loggerName" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>Encoding to be used.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Instance of  that is used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="lineEnding" type="LineEndingMode">
					<xs:annotation>
						<xs:documentation>End of line value if a newline is appended at the end of log message .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxMessageSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum message size in bytes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="newLine" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to append newline at the end of log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="sslProtocols" type="System.Security.Authentication.SslProtocols">
					<xs:annotation>
						<xs:documentation>Get or set the SSL/TLS protocols. Default no SSL/TLS is used. Currently only implemented for TCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="address" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Network address.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="connectionCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Size of the connection cache (number of connections which are kept alive).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepAliveTimeSeconds" type="xs:integer">
					<xs:annotation>
						<xs:documentation>The number of seconds a connection will remain idle before the first keep-alive probe is sent</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxQueueSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum queue size.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxConnections" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Maximum current connections. 0 = no maximum.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onConnectionOverflow" type="NLog.Targets.NetworkTargetConnectionsOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the will be more connections than .</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="onOverflow" type="NLog.Targets.NetworkTargetOverflowAction">
					<xs:annotation>
						<xs:documentation>Action that should be taken if the message is larger than maxMessageSize.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="keepConnection" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to keep connection open whenever possible.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ndlcItemSeparator" type="xs:string">
					<xs:annotation>
						<xs:documentation>NDLC item separator.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ndcItemSeparator" type="xs:string">
					<xs:annotation>
						<xs:documentation>NDC item separator.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeSourceInfo" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include source info (file ltypeName and line number) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNLogData" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include NLog-specific extensions to log4j schema.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  stack.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  stack contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include  dictionary contents.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeCallSite" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include call site (class and method ltypeName) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="appInfo" type="xs:string">
					<xs:annotation>
						<xs:documentation>AppInfo field. By default it's the friendly ltypeName of the current AppDomain.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="loggerName" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Renderer for log4j:event logger-xml-attribute (Default ${logger})</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Null">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="formatMessage" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="formatMessage" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to perform layout calculation.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="OutputDebugString">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="PerfCounter">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="autoCreate" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="categoryName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="counterHelp" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="counterName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="counterType" minOccurs="0" maxOccurs="1" type="System.Diagnostics.PerformanceCounterType" />
					<xs:element ltypeName="incrementValue" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="instanceName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="autoCreate" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether performance counter should be automatically created.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="categoryName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the performance counter category.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="counterHelp" type="xs:string">
					<xs:annotation>
						<xs:documentation>Counter help text.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="counterName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the performance counter.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="counterType" type="System.Diagnostics.PerformanceCounterType">
					<xs:annotation>
						<xs:documentation>Performance counter type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="incrementValue" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>The value by which to increment the counter.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="instanceName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Performance counter instance ltypeName.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="System.Diagnostics.PerformanceCounterType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NumberOfItems32" />
			<xs:enumeration value="NumberOfItems64" />
			<xs:enumeration value="NumberOfItemsHEX32" />
			<xs:enumeration value="NumberOfItemsHEX64" />
			<xs:enumeration value="RateOfCountsPerSecond32" />
			<xs:enumeration value="RateOfCountsPerSecond64" />
			<xs:enumeration value="CountPerTimeInterval32" />
			<xs:enumeration value="CountPerTimeInterval64" />
			<xs:enumeration value="RawFraction" />
			<xs:enumeration value="RawBase" />
			<xs:enumeration value="AverageTimer32" />
			<xs:enumeration value="AverageBase" />
			<xs:enumeration value="AverageCount64" />
			<xs:enumeration value="SampleFraction" />
			<xs:enumeration value="SampleCounter" />
			<xs:enumeration value="SampleBase" />
			<xs:enumeration value="CounterTimer" />
			<xs:enumeration value="CounterTimerInverse" />
			<xs:enumeration value="Timer100Ns" />
			<xs:enumeration value="Timer100NsInverse" />
			<xs:enumeration value="ElapsedTime" />
			<xs:enumeration value="CounterMultiTimer" />
			<xs:enumeration value="CounterMultiTimerInverse" />
			<xs:enumeration value="CounterMultiTimer100Ns" />
			<xs:enumeration value="CounterMultiTimer100NsInverse" />
			<xs:enumeration value="CounterMultiBase" />
			<xs:enumeration value="CounterDelta32" />
			<xs:enumeration value="CounterDelta64" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="PostFilteringWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="defaultFilter" minOccurs="0" maxOccurs="1" type="Condition" />
					<xs:element ltypeName="when" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.Wrappers.FilteringRule" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="defaultFilter" type="Condition">
					<xs:annotation>
						<xs:documentation>Default filter to be applied when no specific rule matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Targets.Wrappers.FilteringRule">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="exists" minOccurs="0" maxOccurs="1" type="Condition" />
			<xs:element ltypeName="filter" minOccurs="0" maxOccurs="1" type="Condition" />
		</xs:choice>
		<xs:attribute ltypeName="exists" type="Condition">
			<xs:annotation>
				<xs:documentation>Condition to be tested.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="filter" type="Condition">
			<xs:annotation>
				<xs:documentation>Resulting filter to be applied when the condition matches.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="RandomizeGroup">
		<xs:complexContent>
			<xs:extension base="CompoundTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="RepeatingWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="repeatCount" minOccurs="0" maxOccurs="1" type="xs:integer" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="repeatCount" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of times to repeat each log message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="RetryingWrapper">
		<xs:complexContent>
			<xs:extension base="WrapperTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="retryCount" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="retryDelayMilliseconds" minOccurs="0" maxOccurs="1" type="xs:integer" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="retryCount" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Number of retries that should be attempted on the wrapped target in case of a failure.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="retryDelayMilliseconds" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Time to wait between retries in milliseconds.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="RoundRobinGroup">
		<xs:complexContent>
			<xs:extension base="CompoundTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="SplitGroup">
		<xs:complexContent>
			<xs:extension base="CompoundTargetBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Trace">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="enableTraceFail" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="rawWrite" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout used to format log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="enableTraceFail" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Forward  to  (Instead of )</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="rawWrite" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Always use  independent of </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="WebService">
		<xs:complexContent>
			<xs:extension base="Target">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.MethodCallParameter" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeBOM" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="methodName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="namespace" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="protocol" minOccurs="0" maxOccurs="1" type="NLog.Targets.WebServiceProtocol" />
					<xs:element ltypeName="proxyAddress" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="encoding" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="url" minOccurs="0" maxOccurs="1" type="xs:anyURI" />
					<xs:element ltypeName="userAgent" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="escapeDataNLogLegacy" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="escapeDataRfc3986" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="preAuthenticate" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="xmlRoot" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="xmlRootNamespace" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.MethodCallParameter" />
					<xs:element ltypeName="proxyType" minOccurs="0" maxOccurs="1" type="NLog.Targets.WebServiceProxyType" />
				</xs:choice>
				<xs:attribute ltypeName="ltypeName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Target supports reuse of internal buffers, and doesn't have to constantly allocate new buffers Required for legacy NLog-targets, that expects buffers to remain stable after Write-method exit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeBOM" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Should we include the BOM (Byte-order-mark) for UTF? Influences the  property. This will only work for UTF-8.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="methodName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Web service method ltypeName. Only used with Soap.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="namespace" type="xs:string">
					<xs:annotation>
						<xs:documentation>Web service namespace. Only used with Soap.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="protocol" type="NLog.Targets.WebServiceProtocol">
					<xs:annotation>
						<xs:documentation>Protocol to be used when calling web service.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="proxyAddress" type="xs:string">
					<xs:annotation>
						<xs:documentation>Custom proxy address, include port separated by a colon</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="encoding" type="xs:string">
					<xs:annotation>
						<xs:documentation>Encoding.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="url" type="xs:anyURI">
					<xs:annotation>
						<xs:documentation>Web service URL.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="userAgent" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Value of the User-agent HTTP header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="escapeDataNLogLegacy" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Value whether escaping be done according to the old NLog style (Very non-standard)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="escapeDataRfc3986" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Value whether escaping be done according to Rfc3986 (Supports Internationalized Resource Identifiers - IRIs)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="preAuthenticate" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to pre-authenticate the HttpWebRequest (Requires 'Authorization' in  parameters)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="xmlRoot" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the root XML element, if POST of XML document chosen. If so, this property must not be null. (see  and ).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="xmlRootNamespace" type="xs:string">
					<xs:annotation>
						<xs:documentation>(optional) root namespace of the XML document, if POST of XML document chosen. (see  and ).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="proxyType" type="NLog.Targets.WebServiceProxyType">
					<xs:annotation>
						<xs:documentation>Proxy configuration when calling web service</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Targets.WebServiceProtocol">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Soap11" />
			<xs:enumeration value="Soap12" />
			<xs:enumeration value="HttpPost" />
			<xs:enumeration value="HttpGet" />
			<xs:enumeration value="JsonPost" />
			<xs:enumeration value="XmlPost" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Targets.WebServiceProxyType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DefaultWebProxy" />
			<xs:enumeration value="AutoProxy" />
			<xs:enumeration value="NoProxy" />
			<xs:enumeration value="ProxyAddress" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="CompoundLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="unbounded" type="Layout" />
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Layout">
		<xs:choice minOccurs="0" maxOccurs="unbounded" />
	</xs:complexType>
	<xs:complexType ltypeName="CsvLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="column" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.CsvColumn" />
					<xs:element ltypeName="customColumnDelimiter" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="delimiter" minOccurs="0" maxOccurs="1" type="NLog.Layouts.CsvColumnDelimiterMode" />
					<xs:element ltypeName="quoteChar" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="quoting" minOccurs="0" maxOccurs="1" type="NLog.Layouts.CsvQuotingMode" />
					<xs:element ltypeName="withHeader" minOccurs="0" maxOccurs="1" type="xs:boolean" />
				</xs:choice>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer layout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header layout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Body layout (can be repeated multiple times).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="customColumnDelimiter" type="xs:string">
					<xs:annotation>
						<xs:documentation>Custom column delimiter value (valid when ColumnDelimiter is set to 'Custom').</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="delimiter" type="NLog.Layouts.CsvColumnDelimiterMode">
					<xs:annotation>
						<xs:documentation>Column delimiter.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="quoteChar" type="xs:string">
					<xs:annotation>
						<xs:documentation>Quote Character.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="quoting" type="NLog.Layouts.CsvQuotingMode">
					<xs:annotation>
						<xs:documentation>Quoting mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="withHeader" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether CVS should include header.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="NLog.Layouts.CsvQuotingMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="All" />
			<xs:enumeration value="Nothing" />
			<xs:enumeration value="Auto" />
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType ltypeName="NLog.Layouts.CsvColumnDelimiterMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Auto" />
			<xs:enumeration value="Comma" />
			<xs:enumeration value="Semicolon" />
			<xs:enumeration value="Tab" />
			<xs:enumeration value="Pipe" />
			<xs:enumeration value="Space" />
			<xs:enumeration value="Custom" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="NLog.Layouts.CsvColumn">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="quoting" minOccurs="0" maxOccurs="1" type="NLog.Layouts.CsvQuotingMode" />
		</xs:choice>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout of the column.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name of the column.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="quoting" type="NLog.Layouts.CsvQuotingMode">
			<xs:annotation>
				<xs:documentation>Override of Quoting mode</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="JsonLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="escapeForwardSlash" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="renderEmptyObject" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="suppressSpaces" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="attribute" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.JsonAttribute" />
					<xs:element ltypeName="excludeEmptyProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="excludeProperties" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeGdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="maxRecursionLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
				</xs:choice>
				<xs:attribute ltypeName="escapeForwardSlash" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Should forward slashes be escaped? If true, / will be converted to \/</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="renderEmptyObject" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to render the empty object value {}</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="suppressSpaces" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to suppress the extra spaces in the output json</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="excludeEmptyProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to exclude null/empty properties from the log event (as JSON)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="excludeProperties" type="xs:string">
					<xs:annotation>
						<xs:documentation>List of property names to exclude when  is true</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log event (as JSON)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log event (as JSON)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeGdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxRecursionLimit" type="xs:integer">
					<xs:annotation>
						<xs:documentation>How far should the JSON serializer follow object references before backing off</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Layouts.JsonAttribute">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="encode" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="escapeForwardSlash" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="escapeUnicode" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeEmptyValue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
		</xs:choice>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout that will be rendered as the attribute's value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name of the attribute.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="encode" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Determines whether or not this attribute will be Json encoded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="escapeForwardSlash" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Should forward slashes be escaped? If true, / will be converted to \/</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="escapeUnicode" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to escape non-ascii characters</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeEmptyValue" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether an attribute with empty value should be included in the output</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="LayoutWithHeaderAndFooter">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="footer" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="header" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
				</xs:choice>
				<xs:attribute ltypeName="footer" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Footer layout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="header" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Header layout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Body layout (can be repeated multiple times).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="Log4JXmlEventLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeCallSite" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeNdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeSourceInfo" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="parameter" minOccurs="0" maxOccurs="unbounded" type="NLog.Targets.NLogViewerParameterInfo" />
				</xs:choice>
				<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeCallSite" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include call site (class and method ltypeName) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log events</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  stack.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeNdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  stack.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeSourceInfo" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include source info (file ltypeName and line number) in the information sent over the network.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="SimpleLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="text" minOccurs="0" maxOccurs="1" type="xs:string" />
				</xs:choice>
				<xs:attribute ltypeName="text" type="xs:string">
					<xs:annotation>
						<xs:documentation>Layout text.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="XmlLayout">
		<xs:complexContent>
			<xs:extension base="Layout">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="propertiesElementKeyAttribute" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="propertiesCollectionItemName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="maxRecursionLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="propertiesElementValueAttribute" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="excludeProperties" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="propertiesElementName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="elementEncode" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="indentXml" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="includeEmptyValue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="elementValue" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="element" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.XmlElement" />
					<xs:element ltypeName="elementName" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="attribute" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.XmlAttribute" />
				</xs:choice>
				<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log event (as XML)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="propertiesElementKeyAttribute" type="xs:string">
					<xs:annotation>
						<xs:documentation>XML attribute ltypeName to use when rendering property-key When null (or empty) then key-attribute is not included</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="propertiesCollectionItemName" type="xs:string">
					<xs:annotation>
						<xs:documentation>XML element ltypeName to use for rendering IList-collections items</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxRecursionLimit" type="xs:integer">
					<xs:annotation>
						<xs:documentation>How far should the XML serializer follow object references before backing off</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeMdc" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to include all properties from the log event (as XML)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="propertiesElementValueAttribute" type="xs:string">
					<xs:annotation>
						<xs:documentation>XML attribute ltypeName to use when rendering property-value When null (or empty) then value-attribute is not included and value is formatted as XML-element-value</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="excludeProperties" type="xs:string">
					<xs:annotation>
						<xs:documentation>List of property names to exclude when  is true</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="propertiesElementName" type="xs:string">
					<xs:annotation>
						<xs:documentation>XML element ltypeName to use when rendering properties</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="elementEncode" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Determines whether or not this attribute will be Xml encoded.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="indentXml" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Auto indent and create new lines</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeEmptyValue" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Whether a ElementValue with empty value should be included in the output</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="elementValue" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Value inside the root XML element</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="elementName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Name of the root XML element</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Layouts.XmlElement">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="encode" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="value" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="attribute" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.XmlAttribute" />
			<xs:element ltypeName="element" minOccurs="0" maxOccurs="unbounded" type="NLog.Layouts.XmlElement" />
			<xs:element ltypeName="includeEmptyValue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="indentXml" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="excludeProperties" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="includeAllProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeEventProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeMdc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeMdlc" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeScopeProperties" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="maxRecursionLimit" minOccurs="0" maxOccurs="1" type="xs:integer" />
			<xs:element ltypeName="propertiesCollectionItemName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="propertiesElementKeyAttribute" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="propertiesElementName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="propertiesElementValueAttribute" minOccurs="0" maxOccurs="1" type="xs:string" />
		</xs:choice>
		<xs:attribute ltypeName="encode" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Determines whether or not this attribute will be Xml encoded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name of the element</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="value" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Value inside the element</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeEmptyValue" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether a ElementValue with empty value should be included in the output</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="indentXml" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Auto indent and create new lines</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="excludeProperties" type="xs:string">
			<xs:annotation>
				<xs:documentation>List of property names to exclude when  is true</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeAllProperties" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Option to include all properties from the log event (as XML)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeEventProperties" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Option to include all properties from the log event (as XML)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeMdc" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeMdlc" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeScopeProperties" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Indicates whether to include contents of the  dictionary.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="maxRecursionLimit" type="xs:integer">
			<xs:annotation>
				<xs:documentation>How far should the XML serializer follow object references before backing off</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="propertiesCollectionItemName" type="xs:string">
			<xs:annotation>
				<xs:documentation>XML element ltypeName to use for rendering IList-collections items</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="propertiesElementKeyAttribute" type="xs:string">
			<xs:annotation>
				<xs:documentation>XML attribute ltypeName to use when rendering property-key When null (or empty) then key-attribute is not included</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="propertiesElementName" type="xs:string">
			<xs:annotation>
				<xs:documentation>XML element ltypeName to use when rendering properties</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="propertiesElementValueAttribute" type="xs:string">
			<xs:annotation>
				<xs:documentation>XML attribute ltypeName to use when rendering property-value When null (or empty) then value-attribute is not included and value is formatted as XML-element-value</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="NLog.Layouts.XmlAttribute">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
			<xs:element ltypeName="ltypeName" minOccurs="0" maxOccurs="1" type="xs:string" />
			<xs:element ltypeName="encode" minOccurs="0" maxOccurs="1" type="xs:boolean" />
			<xs:element ltypeName="includeEmptyValue" minOccurs="0" maxOccurs="1" type="xs:boolean" />
		</xs:choice>
		<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
			<xs:annotation>
				<xs:documentation>Layout that will be rendered as the attribute's value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="ltypeName" type="xs:string">
			<xs:annotation>
				<xs:documentation>Name of the attribute.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="encode" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Determines whether or not this attribute will be Xml encoded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute ltypeName="includeEmptyValue" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether an attribute with empty value should be included in the output</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType ltypeName="when">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="condition" minOccurs="0" maxOccurs="1" type="Condition" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="condition" type="Condition">
					<xs:annotation>
						<xs:documentation>Condition expression.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType ltypeName="FilterResult">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Neutral" />
			<xs:enumeration value="Log" />
			<xs:enumeration value="Ignore" />
			<xs:enumeration value="LogFinal" />
			<xs:enumeration value="IgnoreFinal" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType ltypeName="whenContains">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="ignoreCase" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="substring" minOccurs="0" maxOccurs="1" type="xs:string" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ignoreCase" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to ignore case when comparing strings.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout to be used to filter log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="substring" type="xs:string">
					<xs:annotation>
						<xs:documentation>Substring to be matched.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="whenEqual">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="compareTo" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="ignoreCase" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="compareTo" type="xs:string">
					<xs:annotation>
						<xs:documentation>String to compare the layout to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ignoreCase" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to ignore case when comparing strings.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout to be used to filter log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="whenNotContains">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="ignoreCase" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="substring" minOccurs="0" maxOccurs="1" type="xs:string" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ignoreCase" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to ignore case when comparing strings.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout to be used to filter log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="substring" type="xs:string">
					<xs:annotation>
						<xs:documentation>Substring to be matched.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="whenNotEqual">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="compareTo" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="ignoreCase" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="compareTo" type="xs:string">
					<xs:annotation>
						<xs:documentation>String to compare the layout to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="ignoreCase" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether to ignore case when comparing strings.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout to be used to filter log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="whenRepeated">
		<xs:complexContent>
			<xs:extension base="Filter">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ltypeName="action" minOccurs="0" maxOccurs="1" type="FilterResult" />
					<xs:element ltypeName="defaultFilterCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="includeFirst" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="layout" minOccurs="0" maxOccurs="1" type="Layout" />
					<xs:element ltypeName="maxFilterCacheSize" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="maxLength" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="timeoutSeconds" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="optimizeBufferDefaultLength" minOccurs="0" maxOccurs="1" type="xs:integer" />
					<xs:element ltypeName="optimizeBufferReuse" minOccurs="0" maxOccurs="1" type="xs:boolean" />
					<xs:element ltypeName="filterCountMessageAppendFormat" minOccurs="0" maxOccurs="1" type="xs:string" />
					<xs:element ltypeName="filterCountPropertyName" minOccurs="0" maxOccurs="1" type="xs:string" />
				</xs:choice>
				<xs:attribute ltypeName="action" type="FilterResult">
					<xs:annotation>
						<xs:documentation>Action to be taken when filter matches.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="defaultFilterCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Default number of unique filter values to expect, will automatically increase if needed</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="includeFirst" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Applies the configured action to the initial logevent that starts the timeout period. Used to configure that it should ignore all events until timeout.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="layout" type="SimpleLayoutAttribute">
					<xs:annotation>
						<xs:documentation>Layout to be used to filter log messages.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxFilterCacheSize" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Max number of unique filter values to expect simultaneously</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="maxLength" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Max length of filter values, will truncate if above limit</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="timeoutSeconds" type="xs:integer">
					<xs:annotation>
						<xs:documentation>How long before a filter expires, and logging is accepted again</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferDefaultLength" type="xs:integer">
					<xs:annotation>
						<xs:documentation>Default buffer size for the internal buffers</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="optimizeBufferReuse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Reuse internal buffers, and doesn't have to constantly allocate new buffers</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="filterCountMessageAppendFormat" type="xs:string">
					<xs:annotation>
						<xs:documentation>Append FilterCount to the  when an event is no longer filtered</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute ltypeName="filterCountPropertyName" type="xs:string">
					<xs:annotation>
						<xs:documentation>Insert FilterCount value into  when an event is no longer filtered</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="AccurateLocal">
		<xs:complexContent>
			<xs:extension base="TimeSource">
				<xs:choice minOccurs="0" maxOccurs="unbounded" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="AccurateUTC">
		<xs:complexContent>
			<xs:extension base="TimeSource">
				<xs:choice minOccurs="0" maxOccurs="unbounded" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="FastLocal">
		<xs:complexContent>
			<xs:extension base="TimeSource">
				<xs:choice minOccurs="0" maxOccurs="unbounded" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType ltypeName="FastUTC">
		<xs:complexContent>
			<xs:extension base="TimeSource">
				<xs:choice minOccurs="0" maxOccurs="unbounded" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>